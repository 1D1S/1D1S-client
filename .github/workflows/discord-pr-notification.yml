name: Discord PR Notification

on:
  pull_request:
    types: [opened, closed, reopened]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

jobs:
  discord-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Notify Discord
        uses: actions/github-script@v6
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: '1351796500279197757' # pr-ë¦¬ë·°-ìš”ì²­ ì±„ë„
          ROLE_ID: '1347541606927962152'    # í”„ë¡ íŠ¸ì—”ë“œ ì—­í• 
        with:
          script: |
            const https = require('https');
            
            const token = process.env.DISCORD_BOT_TOKEN;
            const channelId = process.env.CHANNEL_ID;
            const roleId = process.env.ROLE_ID;
            
            const pr = context.payload.pull_request || context.payload.issue;
            const isPr = !!pr.pull_request_url || !!pr.html_url.includes('/pull/');
            
            if (!isPr) { console.log('Not a PR event.'); return; }

            const eventName = context.eventName;
            const action = context.payload.action;
            const prUrl = pr.html_url;
            const prTitle = pr.title;
            const prBody = pr.body || '(ë‚´ìš© ì—†ìŒ)';
            const sender = context.payload.sender;
            
            let content = '';       // ë©˜ì…˜ìš© (Embed ë°–)
            let embeds = [];        // ë””ìì¸ëœ ë©”ì‹œì§€
            let isNew = false;
            let threadName = `ğŸ’¬ ${prTitle.slice(0, 50)}`;

            // 1. PR ìƒì„± (Opened)
            if (eventName === 'pull_request' && action === 'opened') {
              isNew = true;
              content = `<@&${roleId}>`; // ë©˜ì…˜
              embeds = [{
                title: `ğŸš€ ìƒˆë¡œìš´ PR: ${prTitle}`,
                url: prUrl,
                description: prBody.length > 200 ? prBody.slice(0, 200) + '...' : prBody,
                color: 5763719, // Green (#57F287)
                author: {
                  name: sender.login,
                  icon_url: sender.avatar_url
                },
                fields: [
                  { name: 'Repository', value: context.repo.repo, inline: true },
                  { name: 'Branch', value: `${context.payload.pull_request.head.ref} â¡ï¸ ${context.payload.pull_request.base.ref}`, inline: true }
                ],
                footer: { text: 'Review Requested' },
                timestamp: new Date().toISOString()
              }];
            } 
            // 2. PR ë‹«í˜/ë³‘í•© (Closed)
            else if (eventName === 'pull_request' && action === 'closed') {
              const merged = context.payload.pull_request.merged;
              embeds = [{
                title: merged ? `âœ… PR ë³‘í•©ë¨: ${prTitle}` : `â›” PR ë‹«í˜: ${prTitle}`,
                url: prUrl,
                color: merged ? 10181046 : 15548997, // Purple (Merged) or Red (Closed)
                author: { name: sender.login, icon_url: sender.avatar_url },
                footer: { text: merged ? 'Merged' : 'Closed' },
                timestamp: new Date().toISOString()
              }];
            } 
            // 3. ì½”ë©˜íŠ¸/ë¦¬ë·° (Comment)
            else if (eventName === 'issue_comment' || eventName === 'pull_request_review') {
               const commentBody = context.payload.comment ? context.payload.comment.body : 'ë¦¬ë·°ê°€ ì œì¶œë˜ì—ˆìŠµë‹ˆë‹¤.';
               embeds = [{
                description: `ğŸ’¬ **ì½”ë©˜íŠ¸ ë“±ë¡**\n${commentBody.length > 300 ? commentBody.slice(0, 300) + '...' : commentBody}`,
                color: 3447003, // Blue (#3498DB)
                author: { name: sender.login, icon_url: sender.avatar_url },
                url: context.payload.comment ? context.payload.comment.html_url : prUrl
               }];
            } else { return; }

            function request(method, path, body) {
              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: 'discord.com',
                  path: '/api/v10' + path,
                  method,
                  headers: {
                    'Authorization': `Bot ${token}`,
                    'Content-Type': 'application/json'
                  }
                }, res => {
                  let data = '';
                  res.on('data', c => data += c);
                  res.on('end', () => {
                      try { resolve(JSON.parse(data)); }
                      catch(e) { resolve({}); }
                  });
                });
                req.on('error', reject);
                if (body) req.write(JSON.stringify(body));
                req.end();
              });
            }

            async function main() {
              // 1. ìƒˆ PR ì „ì†¡
              if (isNew) {
                const msg = await request('POST', `/channels/${channelId}/messages`, { content, embeds });
                // ë©”ì‹œì§€ ì „ì†¡ í›„ ë°”ë¡œ ìŠ¤ë ˆë“œ ìƒì„± (ì„ íƒ ì‚¬í•­: ê¹”ë”í•œ ê´€ë¦¬ë¥¼ ìœ„í•´ ë¯¸ë¦¬ ìƒì„±)
                if (msg.id) {
                    await request('POST', `/channels/${channelId}/messages/${msg.id}/threads`, {
                        name: threadName,
                        auto_archive_duration: 1440
                    });
                }
                return;
              }

              // 2. ê¸°ì¡´ PR ì—…ë°ì´íŠ¸ (ìŠ¤ë ˆë“œ ì°¾ê¸°)
              const messages = await request('GET', `/channels/${channelId}/messages?limit=50`);
              // Embedê°€ ìˆëŠ” ë©”ì‹œì§€ ì¤‘ì—ì„œ URLì´ ì¼ì¹˜í•˜ëŠ” ê²ƒì„ ì°¾ìŒ
              const originalMsg = messages.find(m => 
                m.author.bot && 
                ((m.embeds && m.embeds[0] && m.embeds[0].url === prUrl) || m.content.includes(prUrl))
              );

              if (originalMsg) {
                let threadId = originalMsg.thread ? originalMsg.thread.id : null;

                // ìŠ¤ë ˆë“œ ì—†ìœ¼ë©´ ìƒì„±
                if (!threadId) {
                   const newThread = await request('POST', `/channels/${channelId}/messages/${originalMsg.id}/threads`, {
                     name: threadName,
                     auto_archive_duration: 1440
                   });
                   if (newThread.id) threadId = newThread.id;
                }

                // ì „ì†¡
                if (threadId) {
                  await request('POST', `/channels/${threadId}/messages`, { embeds });
                } else {
                  await request('POST', `/channels/${channelId}/messages`, { 
                    embeds, message_reference: { message_id: originalMsg.id } 
                  });
                }
              } else {
                // ì›ë³¸ ëª» ì°¾ìœ¼ë©´ ê·¸ëƒ¥ ì „ì†¡ (ë§í¬ í¬í•¨)
                await request('POST', `/channels/${channelId}/messages`, { 
                  content: `[PR Link](${prUrl})`, embeds 
                });
              }
            }

            await main();
```</final>